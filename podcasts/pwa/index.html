<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#6366f1">
    <title>PodLearn - Custom Podcast Player</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.svg">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <style>
        :root {
            --bg-primary: #0f0f0f;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #252525;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #6366f1;
            --accent-hover: #818cf8;
            --alex-color: #3b82f6;
            --sam-color: #10b981;
            --success: #22c55e;
            --warning: #f59e0b;
            --border: #333;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            line-height: 1.5;
            overflow-x: hidden;
            padding-top: var(--safe-top);
            padding-bottom: var(--safe-bottom);
            touch-action: pan-y;
        }

        /* Views */
        .view {
            display: none;
            min-height: 100vh;
            min-height: 100dvh;
        }

        .view.active {
            display: flex;
            flex-direction: column;
        }

        /* Episode List View */
        .episode-list-view {
            padding: 20px;
            padding-bottom: 100px;
        }

        .app-header {
            text-align: center;
            padding: 30px 20px;
            margin-bottom: 10px;
        }

        .app-header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--accent), var(--accent-hover));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .app-header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .badges {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
        }

        .badge.offline {
            background: var(--accent);
            color: white;
        }

        .badge.refresh-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }

        .badge.refresh-btn:hover, .badge.refresh-btn:active {
            background: var(--accent);
        }

        .update-banner {
            background: var(--success);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            margin-top: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 0.9rem;
        }

        .update-banner button {
            background: white;
            color: var(--success);
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
        }

        .badge.progress {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .badge.version {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-family: monospace;
            font-size: 0.7rem;
        }

        .podcast-count {
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Search Bar */
        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 14px 16px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        /* Episode Cards */
        .episode-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .episode-card:hover, .episode-card:active {
            background: var(--bg-tertiary);
            transform: scale(0.98);
        }

        .episode-card.completed {
            border-color: var(--success);
        }

        .episode-card.in-progress {
            border-color: var(--warning);
        }

        .episode-card .ep-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: var(--accent);
            transition: width 0.3s;
        }

        .episode-card .ep-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .episode-card .ep-number {
            font-size: 0.75rem;
            color: var(--accent);
            font-weight: 700;
            letter-spacing: 1px;
        }

        .episode-card .ep-status {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .episode-card .ep-status.completed {
            background: var(--success);
            color: white;
        }

        .episode-card .ep-status.in-progress {
            background: var(--warning);
            color: black;
        }

        .episode-card .ep-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .episode-card .ep-subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .episode-card .ep-meta {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Player View */
        .player-view {
            padding: 20px;
            padding-bottom: 20px;
        }

        .player-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .header-btn {
            background: var(--bg-secondary);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1.3rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .header-btn:active {
            background: var(--accent);
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .player-title {
            flex: 1;
            min-width: 0;
        }

        .player-title h2 {
            font-size: 1rem;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-title .subtitle {
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        /* Collapsible Panels */
        .panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .panel-header {
            padding: 14px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .panel-header h3 {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-toggle {
            color: var(--text-secondary);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }

        .panel.collapsed .panel-toggle {
            transform: rotate(-90deg);
        }

        .panel-content {
            padding: 0 16px 16px;
            transition: max-height 0.3s, opacity 0.2s;
            overflow: hidden;
        }

        .panel.collapsed .panel-content {
            max-height: 0 !important;
            padding: 0 16px;
            opacity: 0;
        }

        /* Voice Settings */
        .voice-row {
            display: flex;
            gap: 12px;
        }

        .voice-select-wrapper {
            flex: 1;
        }

        .voice-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        .voice-label .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .voice-label.alex .dot { background: var(--alex-color); }
        .voice-label.sam .dot { background: var(--sam-color); }

        .voice-select {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            /* Ensure native dropdown works on mobile */
            -webkit-appearance: menulist;
            -moz-appearance: menulist;
            appearance: menulist;
            cursor: pointer;
            min-height: 44px; /* Touch-friendly size */
        }

        .voice-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            line-height: 1.4;
        }

        .voice-count {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .preview-btn {
            margin-top: 12px;
            width: 100%;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .preview-btn:active {
            background: var(--accent);
            color: white;
        }

        /* Timer Settings */
        .timer-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .timer-btn {
            flex: 1;
            min-width: 60px;
            padding: 10px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .timer-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .timer-display {
            margin-top: 12px;
            text-align: center;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .timer-display.active {
            color: var(--warning);
        }

        /* Controls Panel */
        .controls-panel {
            padding: 16px;
        }

        .status-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 16px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-secondary);
            flex-shrink: 0;
        }

        .status-dot.speaking {
            background: var(--accent);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        .status-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-align: center;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .ctrl-btn {
            background: var(--bg-tertiary);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            transition: all 0.15s;
        }

        .ctrl-btn:active {
            transform: scale(0.9);
            background: var(--accent);
        }

        .ctrl-btn.small {
            width: 48px;
            height: 48px;
            font-size: 1.1rem;
        }

        .ctrl-btn.large {
            width: 68px;
            height: 68px;
            font-size: 1.8rem;
            background: var(--accent);
        }

        /* Progress */
        .progress-section {
            margin-bottom: 16px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--alex-color), var(--sam-color));
            border-radius: 4px;
            transition: width 0.1s;
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Speed & Options Row */
        .options-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .speed-section {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-section label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .speed-slider {
            flex: 1;
            accent-color: var(--accent);
        }

        .speed-value {
            min-width: 40px;
            text-align: center;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .auto-play-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .auto-play-toggle.active {
            background: var(--accent);
            color: white;
        }

        /* Speed Presets */
        .speed-presets {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .speed-preset-btn {
            flex: 1;
            min-width: 50px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .speed-preset-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .speed-preset-btn:hover,
        .speed-preset-btn:active {
            transform: scale(0.95);
        }

        /* Settings Panel */
        .settings-grid {
            display: grid;
            gap: 12px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .setting-label {
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .setting-value {
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-input {
            width: 60px;
            padding: 6px 10px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-align: center;
        }

        /* Queue & Mini Player */
        .mini-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 2px solid var(--border);
            padding: 12px 16px;
            padding-bottom: calc(12px + var(--safe-bottom));
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 900;
            cursor: pointer;
        }

        .mini-player.active {
            display: flex;
        }

        .mini-player-info {
            flex: 1;
            min-width: 0;
        }

        .mini-player-title {
            font-size: 0.9rem;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mini-player-subtitle {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .mini-player-controls {
            display: flex;
            gap: 8px;
        }

        .mini-ctrl-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            color: white;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .mini-ctrl-btn:active {
            transform: scale(0.9);
        }

        .queue-panel {
            max-height: 300px;
            overflow-y: auto;
        }

        .queue-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
        }

        .queue-item.playing {
            border-left: 3px solid var(--accent);
        }

        .queue-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent);
        }

        .queue-info {
            flex: 1;
            min-width: 0;
        }

        .queue-title {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .queue-subtitle {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .queue-remove {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-primary);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .queue-remove:active {
            background: var(--accent);
            color: white;
        }

        /* Statistics View */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Theme Toggle */
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .theme-toggle:active {
            background: var(--accent);
            color: white;
        }

        /* Light Theme */
        body.light-theme {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e5e5e5;
            --text-primary: #000000;
            --text-secondary: #666666;
            --border: #d0d0d0;
        }

        /* Share & Export */
        .share-buttons {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(2, 1fr);
        }

        .share-btn {
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .share-btn:active {
            background: var(--accent);
            color: white;
        }

        /* Filter Controls */
        .filter-row {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .sort-select {
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }

        /* Transcript */
        .transcript-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 200px;
            max-height: 35vh;
        }

        .transcript-panel .panel-header {
            border-bottom: 1px solid var(--border);
        }

        .transcript-search {
            padding: 0 16px 12px;
            display: flex;
            gap: 8px;
        }

        .transcript-search input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .transcript-search input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .search-nav {
            display: flex;
            gap: 4px;
        }

        .search-nav button {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .search-nav button:active {
            background: var(--accent);
            color: white;
        }

        .transcript-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            -webkit-overflow-scrolling: touch;
        }

        .transcript-line {
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 10px;
            background: var(--bg-tertiary);
            transition: all 0.2s;
        }

        .transcript-line.current {
            background: var(--bg-primary);
            border-left: 3px solid var(--accent);
        }

        .transcript-line.search-match {
            border: 1px solid var(--warning);
        }

        .transcript-line.search-current {
            border: 2px solid var(--warning);
            background: rgba(245, 158, 11, 0.1);
        }

        .transcript-line .speaker {
            font-weight: 600;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        .transcript-line.alex .speaker { color: var(--alex-color); }
        .transcript-line.sam .speaker { color: var(--sam-color); }

        .transcript-line.direction {
            font-style: italic;
            color: var(--text-secondary);
            background: transparent;
            padding: 8px 12px;
            text-align: center;
        }

        .transcript-line .text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .transcript-line.current .text {
            color: var(--text-primary);
        }

        .highlight {
            background: var(--warning);
            color: black;
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Loading */
        .loading-text {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        /* Install & Sleep Prompts */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            max-width: 320px;
            width: 100%;
            text-align: center;
        }

        .modal h3 {
            margin-bottom: 12px;
            font-size: 1.2rem;
        }

        .modal p {
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 0.95rem;
        }

        .modal .btns {
            display: flex;
            gap: 10px;
        }

        .modal button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        .modal .primary-btn {
            background: var(--accent);
            color: white;
        }

        .modal .secondary-btn {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        /* Swipe indicator */
        .swipe-hint {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 12px;
            color: var(--text-secondary);
            font-size: 1.5rem;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 100;
        }

        .swipe-hint.left { left: 20px; }
        .swipe-hint.right { right: 20px; }
        .swipe-hint.show { opacity: 1; }

        /* Episode complete modal */
        .complete-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .complete-actions button {
            width: 100%;
        }

        /* Bookmarks & Chapters Panel */
        .nav-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .nav-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
        }

        .nav-tab {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-tab.active {
            color: var(--accent);
            background: var(--bg-tertiary);
        }

        .nav-content {
            max-height: 200px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .nav-content[data-tab]:not(.active) {
            display: none;
        }

        /* Chapters List */
        .chapter-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.2s;
        }

        .chapter-item:last-child {
            border-bottom: none;
        }

        .chapter-item:active {
            background: var(--bg-tertiary);
        }

        .chapter-item.current {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--accent);
        }

        .chapter-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent);
            flex-shrink: 0;
        }

        .chapter-item.current .chapter-number {
            background: var(--accent);
            color: white;
        }

        .chapter-info {
            flex: 1;
            min-width: 0;
        }

        .chapter-title {
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chapter-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Bookmarks List */
        .bookmark-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .bookmark-item:last-child {
            border-bottom: none;
        }

        .bookmark-content {
            flex: 1;
            cursor: pointer;
            min-width: 0;
        }

        .bookmark-position {
            font-size: 0.75rem;
            color: var(--accent);
            margin-bottom: 2px;
        }

        .bookmark-note {
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bookmark-preview {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bookmark-delete {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            cursor: pointer;
            padding: 4px;
            flex-shrink: 0;
        }

        .bookmark-delete:active {
            color: #ef4444;
        }

        .no-items {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .add-bookmark-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px;
            background: var(--bg-tertiary);
            border: 1px dashed var(--border);
            border-radius: 10px;
            margin: 12px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .add-bookmark-btn:active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Bookmark Modal */
        .bookmark-modal input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 16px;
        }

        .bookmark-modal input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .bookmark-modal .context-preview {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 16px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            max-height: 80px;
            overflow: hidden;
        }

        /* Current chapter indicator */
        .current-chapter-badge {
            font-size: 0.75rem;
            color: var(--accent);
            margin-top: 4px;
        }

        /* Podcasts View */
        .podcasts-view {
            padding: 20px;
            padding-bottom: 100px;
        }

        .podcast-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
        }

        .podcast-card:hover, .podcast-card:active {
            background: var(--bg-tertiary);
            transform: scale(0.98);
        }

        .podcast-card-header {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }

        .podcast-icon {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            flex-shrink: 0;
        }

        .podcast-info {
            flex: 1;
            min-width: 0;
        }

        .podcast-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .podcast-subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .podcast-meta {
            display: flex;
            gap: 12px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .podcast-progress-bar {
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            margin-top: 12px;
            overflow: hidden;
        }

        .podcast-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            border-radius: 2px;
            transition: width 0.3s;
        }

        .nav-bar {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .nav-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--accent);
            font-size: 0.9rem;
            padding: 8px 14px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .nav-btn:hover, .nav-btn:active {
            background: var(--accent);
            color: white;
        }

        .nav-title {
            color: var(--text-secondary);
            font-size: 0.85rem;
            flex: 1;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .breadcrumb {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        /* Add Podcast Button */
        .add-podcast-card {
            background: var(--bg-secondary);
            border: 2px dashed var(--border);
            border-radius: 16px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-podcast-card:active {
            background: var(--bg-tertiary);
            border-color: var(--accent);
        }

        .add-podcast-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .add-podcast-text {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        /* Create Podcast Modal */
        .create-modal .modal {
            max-width: 400px;
        }

        .create-modal textarea {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.95rem;
            margin-bottom: 12px;
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
        }

        .create-modal textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .create-modal input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .create-modal input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .create-modal label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .color-picker {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .color-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
        }

        .color-option.selected {
            border-color: white;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <!-- Podcasts Home View -->
    <div id="podcasts-view" class="view active podcasts-view">
        <header class="app-header">
            <h1>PodLearn</h1>
            <p>Your Custom Podcast Player</p>
            <div class="badges">
                <span class="badge offline" id="offline-badge-home" style="display:none">Offline Ready</span>
                <span class="badge version" id="version-badge">v--</span>
                <button class="badge refresh-btn" id="refresh-btn" onclick="forceRefresh()">‚Üª Refresh</button>
            </div>
            <div id="update-banner" class="update-banner" style="display:none">
                New content available! <button onclick="applyUpdate()">Update Now</button>
            </div>
            <div id="podcast-count" class="podcast-count"></div>
        </header>

        <div class="search-container">
            <input type="text" class="search-input" id="podcast-search" placeholder="Search podcasts...">
        </div>

        <div id="podcasts-list">
            <p class="loading-text">Loading podcasts...</p>
        </div>
    </div>

    <!-- Episode List View -->
    <div id="list-view" class="view episode-list-view">
        <div class="nav-bar">
            <button class="nav-btn" id="back-to-podcasts" title="Back to all podcasts">
                <span>‚Üê</span> Home
            </button>
            <span class="nav-title" id="nav-podcast-name">Podcast Name</span>
        </div>
        <header class="app-header" id="podcast-header">
            <h1 id="current-podcast-title">Podcast</h1>
            <p id="current-podcast-subtitle">Subtitle</p>
            <div class="badges">
                <span class="badge offline" id="offline-badge" style="display:none">Offline Ready</span>
                <span class="badge progress" id="total-progress-badge">0% Complete</span>
            </div>
        </header>

        <div class="search-container">
            <input type="text" class="search-input" id="episode-search" placeholder="Search episodes...">
        </div>

        <div class="filter-row">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="unplayed">Unplayed</button>
            <button class="filter-btn" data-filter="in-progress">In Progress</button>
            <button class="filter-btn" data-filter="completed">Completed</button>
            <select class="sort-select" id="episode-sort">
                <option value="default">Default Order</option>
                <option value="newest">Newest First</option>
                <option value="oldest">Oldest First</option>
                <option value="title">Title A-Z</option>
                <option value="progress">By Progress</option>
            </select>
        </div>

        <div id="episode-list">
            <p class="loading-text">Loading episodes...</p>
        </div>
    </div>

    <!-- Player View -->
    <div id="player-view" class="view player-view">
        <div class="player-header">
            <button class="header-btn" id="back-to-list" title="Back to episodes">‚Üê</button>
            <div class="player-title">
                <p class="breadcrumb" id="player-breadcrumb">Home ‚Ä∫ Podcast ‚Ä∫ Episode</p>
                <h2 id="player-episode-title">Episode</h2>
            </div>
            <div class="header-actions">
                <button class="header-btn" id="share-btn" title="Share & Export">üì§</button>
                <button class="header-btn" id="stats-btn" title="Statistics">üìä</button>
                <button class="header-btn" id="sleep-timer-btn" title="Sleep Timer">üí§</button>
                <button class="header-btn" id="home-from-player" title="Go to Home">üè†</button>
            </div>
        </div>

        <!-- Voice Panel -->
        <div class="panel" id="voice-panel">
            <div class="panel-header">
                <h3>Voices</h3>
                <span class="panel-toggle">‚ñº</span>
            </div>
            <div class="panel-content" style="max-height: 300px;">
                <div class="voice-count" id="voice-count">Loading voices...</div>
                <div class="voice-row">
                    <div class="voice-select-wrapper">
                        <div class="voice-label alex"><span class="dot"></span>Host 1</div>
                        <select class="voice-select" id="alex-voice"></select>
                    </div>
                    <div class="voice-select-wrapper">
                        <div class="voice-label sam"><span class="dot"></span>Host 2</div>
                        <select class="voice-select" id="sam-voice"></select>
                    </div>
                </div>
                <button class="preview-btn" id="preview-voices">Preview Voices</button>
                <div class="voice-info" id="voice-info">
                    <strong>Tip:</strong> On Android, each voice in this list represents a downloaded voice pack.
                    To change the voice variant (I, II, III), go to Settings ‚Üí Accessibility ‚Üí Text-to-Speech ‚Üí
                    tap the gear icon next to your TTS engine.
                </div>
            </div>
        </div>

        <!-- Chapters & Bookmarks Panel -->
        <div class="nav-panel">
            <div class="nav-tabs">
                <button class="nav-tab active" data-tab="chapters">Chapters</button>
                <button class="nav-tab" data-tab="bookmarks">Bookmarks</button>
                <button class="nav-tab" data-tab="queue">Queue</button>
            </div>
            <div class="nav-content active" data-tab="chapters" id="chapters-list">
                <div class="no-items">Loading chapters...</div>
            </div>
            <div class="nav-content" data-tab="bookmarks" id="bookmarks-list">
                <button class="add-bookmark-btn" id="add-bookmark-btn">+ Add Bookmark Here</button>
                <div class="no-items">No bookmarks yet</div>
            </div>
            <div class="nav-content" data-tab="queue">
                <div class="queue-panel" id="queue-list">
                    <div class="no-items">Queue is empty</div>
                </div>
            </div>
        </div>

        <!-- Settings Panel -->
        <div class="panel collapsed" id="settings-panel">
            <div class="panel-header">
                <h3>Settings</h3>
                <span class="panel-toggle">‚ñº</span>
            </div>
            <div class="panel-content">
                <div class="settings-grid">
                    <div class="setting-item">
                        <span class="setting-label">Skip Forward</span>
                        <div class="setting-value">
                            <input type="number" class="setting-input" id="skip-forward-interval" value="10" min="5" max="60" step="5">
                            <span>sec</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Skip Backward</span>
                        <div class="setting-value">
                            <input type="number" class="setting-input" id="skip-backward-interval" value="10" min="5" max="60" step="5">
                            <span>sec</span>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Voice Boost</span>
                        <div class="setting-value">
                            <div class="auto-play-toggle" id="voice-boost-toggle">
                                <span>Off</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Silence Trim</span>
                        <div class="setting-value">
                            <div class="auto-play-toggle" id="silence-trim-toggle">
                                <span>Off</span>
                            </div>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Theme</span>
                        <div class="setting-value">
                            <div class="theme-toggle" id="theme-toggle">
                                <span>üåô Dark</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controls Panel -->
        <div class="panel controls-panel">
            <div class="status-row">
                <div class="status-dot" id="status-dot"></div>
                <div style="flex:1">
                    <span class="status-text" id="status-text">Ready</span>
                    <div class="current-chapter-badge" id="current-chapter-badge"></div>
                </div>
            </div>

            <div class="control-buttons">
                <button class="ctrl-btn small" id="prev-btn" title="Back 10 lines">‚èÆ</button>
                <button class="ctrl-btn small" id="back-btn" title="Back 5 lines">‚Ü∫</button>
                <button class="ctrl-btn large" id="play-btn" title="Play/Pause">‚ñ∂</button>
                <button class="ctrl-btn small" id="fwd-btn" title="Forward 5 lines">‚Üª</button>
                <button class="ctrl-btn small" id="next-btn" title="Forward 10 lines">‚è≠</button>
            </div>

            <div class="progress-section">
                <div class="progress-bar" id="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width:0%"></div>
                </div>
                <div class="progress-labels">
                    <span id="current-pos">Line 0</span>
                    <span id="time-remaining">~60 min left</span>
                    <span id="total-pos">of 0</span>
                </div>
            </div>

            <div class="speed-presets">
                <button class="speed-preset-btn" data-speed="0.75">0.75x</button>
                <button class="speed-preset-btn active" data-speed="1">1x</button>
                <button class="speed-preset-btn" data-speed="1.25">1.25x</button>
                <button class="speed-preset-btn" data-speed="1.5">1.5x</button>
                <button class="speed-preset-btn" data-speed="2">2x</button>
            </div>

            <div class="options-row">
                <div class="speed-section">
                    <label>Speed</label>
                    <input type="range" class="speed-slider" id="speed-slider" min="0.5" max="2" step="0.1" value="1">
                    <span class="speed-value" id="speed-value">1.0x</span>
                </div>
                <div class="auto-play-toggle" id="auto-play-toggle" title="Auto-play next episode">
                    <span>Auto</span>
                </div>
            </div>
        </div>

        <!-- Transcript Panel -->
        <div class="panel transcript-panel" id="transcript-panel">
            <div class="panel-header">
                <h3>Transcript</h3>
                <span class="panel-toggle">‚ñº</span>
            </div>
            <div class="transcript-search">
                <input type="text" id="transcript-search-input" placeholder="Search transcript...">
                <div class="search-nav">
                    <button id="search-prev">‚Üë</button>
                    <button id="search-next">‚Üì</button>
                </div>
            </div>
            <div class="transcript-content" id="transcript-content">
                <p class="loading-text">Loading transcript...</p>
            </div>
        </div>
    </div>

    <!-- Swipe Hints -->
    <div class="swipe-hint left" id="swipe-left">‚è™</div>
    <div class="swipe-hint right" id="swipe-right">‚è©</div>

    <!-- Sleep Timer Modal -->
    <div class="modal-overlay" id="sleep-modal">
        <div class="modal">
            <h3>Sleep Timer</h3>
            <p>Auto-stop playback after:</p>
            <div class="timer-row">
                <button class="timer-btn" data-minutes="15">15m</button>
                <button class="timer-btn" data-minutes="30">30m</button>
                <button class="timer-btn" data-minutes="45">45m</button>
                <button class="timer-btn" data-minutes="60">1hr</button>
            </div>
            <div class="timer-display" id="timer-display">No timer set</div>
            <div class="btns" style="margin-top: 16px;">
                <button class="secondary-btn" id="cancel-timer">Cancel Timer</button>
                <button class="primary-btn" id="close-sleep-modal">Done</button>
            </div>
        </div>
    </div>

    <!-- Episode Complete Modal -->
    <div class="modal-overlay" id="complete-modal">
        <div class="modal">
            <h3>Episode Complete! üéâ</h3>
            <p id="complete-message">Great job finishing this episode!</p>
            <div class="complete-actions">
                <button class="primary-btn" id="play-next-episode">Play Next Episode</button>
                <button class="secondary-btn" id="back-to-episodes">Back to Episodes</button>
            </div>
        </div>
    </div>

    <!-- Add Bookmark Modal -->
    <div class="modal-overlay" id="bookmark-modal">
        <div class="modal bookmark-modal">
            <h3>Add Bookmark</h3>
            <p id="bookmark-position-text">Line 0 of 0</p>
            <div class="context-preview" id="bookmark-context"></div>
            <input type="text" id="bookmark-note-input" placeholder="Add a note (optional)">
            <div class="btns">
                <button class="secondary-btn" id="cancel-bookmark">Cancel</button>
                <button class="primary-btn" id="save-bookmark">Save</button>
            </div>
        </div>
    </div>

    <!-- Install Prompt -->
    <div class="modal-overlay" id="install-modal">
        <div class="modal">
            <h3>Install App</h3>
            <p>Install for offline use during your flight!</p>
            <div class="btns">
                <button class="secondary-btn" id="dismiss-install">Later</button>
                <button class="primary-btn" id="do-install">Install</button>
            </div>
        </div>
    </div>

    <!-- Create Podcast Info Modal -->
    <div class="modal-overlay create-modal" id="create-modal">
        <div class="modal">
            <h3>Create Your Own Podcast</h3>
            <p style="margin-bottom: 16px;">To add your own podcasts, follow these steps:</p>
            <div style="text-align: left; background: var(--bg-tertiary); padding: 16px; border-radius: 10px; font-size: 0.85rem; line-height: 1.8;">
                <p><strong>1.</strong> Create a new folder in <code>shows/</code></p>
                <p><strong>2.</strong> Add a <code>podcast.json</code> file with your podcast info</p>
                <p><strong>3.</strong> Add episode <code>.md</code> files with dialogue</p>
                <p><strong>4.</strong> Run <code>node build-episodes.js</code></p>
                <p><strong>5.</strong> Push to GitHub to deploy</p>
            </div>
            <p style="margin-top: 16px; font-size: 0.85rem; color: var(--text-secondary);">See the template in <code>shows/_template/</code></p>
            <div class="btns" style="margin-top: 16px;">
                <button class="primary-btn" id="close-create-modal">Got it</button>
            </div>
        </div>
    </div>

    <!-- Share/Export Modal -->
    <div class="modal-overlay" id="share-modal">
        <div class="modal">
            <h3>Share & Export</h3>
            <p style="margin-bottom: 16px; font-size: 0.9rem;">Share this episode or export your data</p>
            <div class="share-buttons">
                <button class="share-btn" id="share-timestamp-btn">
                    üìç Share Current Position
                </button>
                <button class="share-btn" id="share-episode-btn">
                    üéß Share Episode
                </button>
                <button class="share-btn" id="export-bookmarks-btn">
                    üìö Export Bookmarks
                </button>
                <button class="share-btn" id="export-progress-btn">
                    üíæ Export Progress
                </button>
            </div>
            <div class="btns" style="margin-top: 16px;">
                <button class="primary-btn" id="close-share-modal">Done</button>
            </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div class="modal-overlay" id="stats-modal">
        <div class="modal" style="max-width: 400px;">
            <h3>Listening Statistics</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="stat-total-time">0h</div>
                    <div class="stat-label">Total Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-episodes-completed">0</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-current-streak">0</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-avg-speed">1.0x</div>
                    <div class="stat-label">Avg Speed</div>
                </div>
            </div>
            <div style="margin-top: 20px; padding: 16px; background: var(--bg-tertiary); border-radius: 10px;">
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">Time Saved (at current speed)</div>
                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent);" id="stat-time-saved">0h 0m</div>
            </div>
            <div class="btns" style="margin-top: 16px;">
                <button class="primary-btn" id="close-stats-modal">Done</button>
            </div>
        </div>
    </div>

    <!-- Mini Player -->
    <div class="mini-player" id="mini-player">
        <div class="mini-player-info">
            <div class="mini-player-title" id="mini-player-title">Episode Title</div>
            <div class="mini-player-subtitle" id="mini-player-subtitle">Podcast Name</div>
        </div>
        <div class="mini-player-controls">
            <button class="mini-ctrl-btn" id="mini-play-btn">‚ñ∂</button>
        </div>
    </div>

    <script>
        // ===== APP VERSION =====
        const APP_VERSION = '2.1.2';

        // ===== AUTO-UPDATE CHECK =====
        // Runs immediately - fetches version from server bypassing all caches
        // If version mismatch, clears everything and reloads
        (async function checkForUpdates() {
            try {
                const response = await fetch('version.json?_=' + Date.now(), {
                    cache: 'no-store',
                    headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' }
                });
                if (response.ok) {
                    const data = await response.json();
                    console.log('Version check - Local:', APP_VERSION, 'Server:', data.version);

                    if (data.version !== APP_VERSION) {
                        console.log('Update available! Clearing caches and reloading...');

                        // Unregister all service workers
                        if ('serviceWorker' in navigator) {
                            const registrations = await navigator.serviceWorker.getRegistrations();
                            for (const reg of registrations) {
                                await reg.unregister();
                            }
                        }

                        // Clear all caches
                        if ('caches' in window) {
                            const cacheNames = await caches.keys();
                            for (const name of cacheNames) {
                                await caches.delete(name);
                            }
                        }

                        // Hard reload
                        window.location.reload(true);
                        return;
                    }
                }
            } catch (e) {
                console.log('Version check skipped (offline?):', e.message);
            }
        })();

        // Flag to track if podcasts are loaded
        let podcastsLoaded = false;

        // Load podcasts.js with cache-busting
        (function() {
            const script = document.createElement('script');
            script.src = 'podcasts.js?v=' + Date.now();
            script.onload = function() {
                console.log('podcasts.js loaded, PODCASTS:', typeof PODCASTS !== 'undefined' ? PODCASTS.length + ' podcasts' : 'undefined');
                podcastsLoaded = true;
                // Re-render now that podcasts are loaded
                if (typeof renderPodcastsList === 'function') {
                    renderPodcastsList();
                }
            };
            script.onerror = function() {
                console.error('Failed to load podcasts.js');
                document.getElementById('podcasts-list').innerHTML = '<p class="loading-text">Failed to load podcasts. Try refreshing.</p>';
            };
            document.head.appendChild(script);
        })();

        // ===== STATE =====
        let currentPodcast = null;
        let currentEpisode = null;
        let dialogueLines = [];
        let currentLineIndex = 0;
        let isPlaying = false;
        let isPaused = false;
        let voices = [];
        let alexVoice = null;
        let samVoice = null;
        let speechRate = 1.0;
        let autoPlayNext = true;
        let sleepTimer = null;
        let sleepEndTime = null;
        let searchMatches = [];
        let searchIndex = 0;
        const synth = window.speechSynthesis;

        // Audio playback state (for pre-generated audio)
        let audioManifest = null;  // null = use TTS, array = use audio files
        let audioElement = null;
        let useAudio = false;  // true when pre-generated audio is available
        let audioSegmentDurations = [];  // actual duration of each audio segment in seconds
        let totalAudioDuration = 0;  // total duration of all audio segments

        // New feature state
        let skipForwardInterval = parseInt(localStorage.getItem('skipForwardInterval') || '10');
        let skipBackwardInterval = parseInt(localStorage.getItem('skipBackwardInterval') || '10');
        let voiceBoostEnabled = localStorage.getItem('voiceBoostEnabled') === 'true';
        let silenceTrimEnabled = localStorage.getItem('silenceTrimEnabled') === 'true';
        let currentTheme = localStorage.getItem('theme') || 'dark';
        let currentFilter = 'all';
        let currentSort = 'default';
        let playQueue = JSON.parse(localStorage.getItem('playQueue') || '[]');
        let listeningStats = JSON.parse(localStorage.getItem('listeningStats') || '{"totalTime": 0, "episodesCompleted": 0, "lastListenDate": null, "currentStreak": 0, "speedSum": 0, "speedCount": 0}');

        // Web Audio API for enhancements
        let audioContext = null;
        let gainNode = null;
        let audioSource = null;
        let analyser = null;

        // Mini player state
        let showMiniPlayer = false;

        // Wake Lock API for keeping screen on during playback
        let wakeLock = null;

        // Request wake lock to prevent device from sleeping
        async function requestWakeLock() {
            if (!('wakeLock' in navigator)) {
                console.log('Wake Lock API not supported');
                return;
            }

            try {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock acquired');

                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock released');
                });
            } catch (err) {
                console.warn('Wake Lock request failed:', err);
            }
        }

        // Release wake lock when playback stops
        async function releaseWakeLock() {
            if (wakeLock) {
                try {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Wake Lock released manually');
                } catch (err) {
                    console.warn('Wake Lock release failed:', err);
                }
            }
        }

        // ===== PODCASTS HOME =====
        function renderPodcastsList(filter = '') {
            // Update version badge
            document.getElementById('version-badge').textContent = 'v' + APP_VERSION;

            if (typeof PODCASTS === 'undefined') {
                if (!podcastsLoaded) {
                    document.getElementById('podcasts-list').innerHTML = '<p class="loading-text">Loading podcasts...</p>';
                    document.getElementById('podcast-count').textContent = 'Loading...';
                } else {
                    document.getElementById('podcasts-list').innerHTML = '<p class="loading-text">No podcasts found. Try refreshing.</p>';
                    document.getElementById('podcast-count').textContent = '0 podcasts loaded';
                }
                return;
            }

            // Show podcast count
            const totalEpisodes = PODCASTS.reduce((sum, p) => sum + p.episodes.length, 0);
            document.getElementById('podcast-count').textContent = `${PODCASTS.length} podcasts ¬∑ ${totalEpisodes} episodes`;

            const state = loadState();
            const listEl = document.getElementById('podcasts-list');
            listEl.innerHTML = '';

            const filterLower = filter.toLowerCase();

            PODCASTS.forEach(podcast => {
                if (filter && !podcast.title.toLowerCase().includes(filterLower) &&
                    !podcast.subtitle.toLowerCase().includes(filterLower)) {
                    return;
                }

                // Calculate podcast progress
                let totalProgress = 0;
                const epCount = podcast.episodes.length;
                podcast.episodes.forEach(ep => {
                    const epKey = `${podcast.id}-${ep.id}`;
                    const progress = state.episodeProgress?.[epKey] || { percent: 0 };
                    const isComplete = state.completedEpisodes?.includes(epKey);
                    totalProgress += isComplete ? 100 : progress.percent;
                });
                const avgProgress = epCount > 0 ? Math.round(totalProgress / epCount) : 0;

                const card = document.createElement('div');
                card.className = 'podcast-card';
                card.innerHTML = `
                    <div class="podcast-card-header">
                        <div class="podcast-icon" style="background: ${podcast.color}20; color: ${podcast.color}">
                            ${podcast.icon || 'üéôÔ∏è'}
                        </div>
                        <div class="podcast-info">
                            <div class="podcast-title">${podcast.title}</div>
                            <div class="podcast-subtitle">${podcast.subtitle}</div>
                            <div class="podcast-meta">
                                <span>${epCount} episodes</span>
                                <span>~${epCount * 60} min</span>
                            </div>
                        </div>
                    </div>
                    <div class="podcast-progress-bar">
                        <div class="podcast-progress-fill" style="width: ${avgProgress}%"></div>
                    </div>
                `;

                card.addEventListener('click', () => openPodcast(podcast));
                listEl.appendChild(card);
            });

            // Add "Create Podcast" card
            const addCard = document.createElement('div');
            addCard.className = 'add-podcast-card';
            addCard.innerHTML = `
                <div class="add-podcast-icon">+</div>
                <div class="add-podcast-text">Create Your Own Podcast</div>
            `;
            addCard.addEventListener('click', () => {
                document.getElementById('create-modal').classList.add('show');
            });
            listEl.appendChild(addCard);
        }

        function openPodcast(podcast) {
            currentPodcast = podcast;
            document.getElementById('current-podcast-title').textContent = podcast.title;
            document.getElementById('current-podcast-subtitle').textContent = podcast.subtitle;
            document.getElementById('nav-podcast-name').textContent = podcast.title;

            // Update accent color
            document.documentElement.style.setProperty('--accent', podcast.color || '#6366f1');

            document.getElementById('podcasts-view').classList.remove('active');
            document.getElementById('list-view').classList.add('active');
            renderEpisodeList();
        }

        document.getElementById('back-to-podcasts').addEventListener('click', () => {
            stopPlayback();
            saveState();
            currentPodcast = null;
            document.getElementById('list-view').classList.remove('active');
            document.getElementById('podcasts-view').classList.add('active');
            // Reset accent color
            document.documentElement.style.setProperty('--accent', '#6366f1');
            renderPodcastsList();
        });

        document.getElementById('podcast-search').addEventListener('input', e => {
            renderPodcastsList(e.target.value);
        });

        document.getElementById('close-create-modal').addEventListener('click', () => {
            document.getElementById('create-modal').classList.remove('show');
        });

        // ===== PERSISTENCE =====
        const STORAGE_KEY = 'tlu_podcast_state';

        function saveState() {
            const state = {
                episodeProgress: {},
                completedEpisodes: [],
                bookmarks: {},
                speechRate,
                autoPlayNext,
                alexVoiceIndex: document.getElementById('alex-voice').value,
                samVoiceIndex: document.getElementById('sam-voice').value
            };

            // Save current podcast/episode
            if (currentPodcast) {
                state.currentPodcastId = currentPodcast.id;
            }
            if (currentEpisode) {
                state.currentEpisodeId = currentEpisode.id;
                state.currentLineIndex = currentLineIndex;
            }

            // Get existing progress
            const existing = loadState();
            if (existing.episodeProgress) {
                state.episodeProgress = existing.episodeProgress;
            }
            if (existing.completedEpisodes) {
                state.completedEpisodes = existing.completedEpisodes;
            }
            if (existing.bookmarks) {
                state.bookmarks = existing.bookmarks;
            }

            // Update current episode progress (with podcast-scoped key)
            if (currentPodcast && currentEpisode && dialogueLines.length > 0) {
                const epKey = `${currentPodcast.id}-${currentEpisode.id}`;
                const pct = Math.round((currentLineIndex / dialogueLines.length) * 100);
                state.episodeProgress[epKey] = {
                    line: currentLineIndex,
                    percent: pct,
                    timestamp: Date.now()
                };

                // Mark complete if >= 98%
                if (pct >= 98 && !state.completedEpisodes.includes(epKey)) {
                    state.completedEpisodes.push(epKey);
                    // Track in stats
                    listeningStats.episodesCompleted += 1;
                    localStorage.setItem('listeningStats', JSON.stringify(listeningStats));
                }
            }

            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function loadState() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
            } catch {
                return {};
            }
        }

        function restoreState() {
            const state = loadState();
            if (state.speechRate) {
                speechRate = state.speechRate;
                document.getElementById('speed-slider').value = speechRate;
                document.getElementById('speed-value').textContent = `${speechRate.toFixed(1)}x`;
                // Update speed preset button highlights
                document.querySelectorAll('.speed-preset-btn').forEach(b => {
                    b.classList.toggle('active', Math.abs(parseFloat(b.dataset.speed) - speechRate) < 0.01);
                });
            }
            if (state.autoPlayNext !== undefined) {
                autoPlayNext = state.autoPlayNext;
                document.getElementById('auto-play-toggle').classList.toggle('active', autoPlayNext);
            }
            return state;
        }

        // ===== VOICE LOADING =====
        function loadVoices() {
            voices = synth.getVoices();
            if (voices.length === 0) {
                setTimeout(loadVoices, 100);
                return;
            }

            console.log('Available voices:', voices.length, voices.map(v => v.name));

            // Update voice count display
            const voiceCountEl = document.getElementById('voice-count');
            const englishCount = voices.filter(v => v.lang.toLowerCase().startsWith('en')).length;
            voiceCountEl.textContent = `${voices.length} voices available (${englishCount} English)`;

            const alexSelect = document.getElementById('alex-voice');
            const samSelect = document.getElementById('sam-voice');
            alexSelect.innerHTML = '';
            samSelect.innerHTML = '';

            // Categorize voices
            const maleKeywords = ['male', 'david', 'james', 'daniel', 'guy', 'aaron', 'mark', 'matthew', 'google us english', 'google uk english male'];
            const femaleKeywords = ['female', 'samantha', 'karen', 'victoria', 'fiona', 'zira', 'susan', 'google uk english female'];

            const maleVoices = [];
            const femaleVoices = [];
            const englishVoices = [];

            voices.forEach((voice, index) => {
                const name = voice.name.toLowerCase();
                const lang = voice.lang.toLowerCase();

                // Prefer English voices
                if (lang.startsWith('en')) {
                    englishVoices.push({ voice, index });
                }

                if (maleKeywords.some(k => name.includes(k))) {
                    maleVoices.push({ voice, index });
                } else if (femaleKeywords.some(k => name.includes(k))) {
                    femaleVoices.push({ voice, index });
                }
            });

            // Populate select options
            voices.forEach((voice, index) => {
                const opt1 = document.createElement('option');
                opt1.value = index;
                opt1.textContent = `${voice.name} (${voice.lang})`;
                alexSelect.appendChild(opt1);

                const opt2 = document.createElement('option');
                opt2.value = index;
                opt2.textContent = `${voice.name} (${voice.lang})`;
                samSelect.appendChild(opt2);
            });

            // Restore saved voices or use defaults
            const state = loadState();
            let alexIdx = 0;
            let samIdx = voices.length > 1 ? 1 : 0;

            // Try to get saved voices
            if (state.alexVoiceIndex !== undefined && voices[parseInt(state.alexVoiceIndex, 10)]) {
                alexIdx = parseInt(state.alexVoiceIndex, 10);
            } else if (maleVoices.length > 0) {
                alexIdx = maleVoices[0].index;
            } else if (englishVoices.length > 0) {
                alexIdx = englishVoices[0].index;
            }

            if (state.samVoiceIndex !== undefined && voices[parseInt(state.samVoiceIndex, 10)]) {
                samIdx = parseInt(state.samVoiceIndex, 10);
            } else if (femaleVoices.length > 0) {
                samIdx = femaleVoices[0].index;
            } else if (englishVoices.length > 1) {
                // Pick a different English voice than Alex
                samIdx = englishVoices.find(v => v.index !== alexIdx)?.index || (alexIdx === 0 ? 1 : 0);
            }

            // Ensure different voices if possible
            if (samIdx === alexIdx && voices.length > 1) {
                samIdx = alexIdx === 0 ? 1 : 0;
            }

            alexSelect.value = alexIdx;
            samSelect.value = samIdx;
            alexVoice = voices[alexIdx];
            samVoice = voices[samIdx];

            console.log('Alex voice:', alexVoice?.name);
            console.log('Sam voice:', samVoice?.name);
        }

        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = loadVoices;
        }
        loadVoices();

        document.getElementById('alex-voice').addEventListener('change', e => {
            const idx = parseInt(e.target.value, 10);
            alexVoice = voices[idx];
            console.log('Alex voice set to:', alexVoice?.name);
            saveState();
        });
        document.getElementById('sam-voice').addEventListener('change', e => {
            const idx = parseInt(e.target.value, 10);
            samVoice = voices[idx];
            console.log('Sam voice set to:', samVoice?.name);
            saveState();
        });

        // Preview voices
        document.getElementById('preview-voices').addEventListener('click', () => {
            synth.cancel();
            const alexUtter = new SpeechSynthesisUtterance("Hi, I'm Alex, your technical expert.");
            if (alexVoice) alexUtter.voice = alexVoice;
            alexUtter.rate = speechRate;
            alexUtter.pitch = 0.9;

            const samUtter = new SpeechSynthesisUtterance("And I'm Sam, asking the questions you're thinking.");
            if (samVoice) samUtter.voice = samVoice;
            samUtter.rate = speechRate;
            samUtter.pitch = 1.1;

            synth.speak(alexUtter);
            synth.speak(samUtter);
        });

        // ===== MARKDOWN PARSING =====
        function parseMarkdown(content) {
            const lines = content.split('\n');
            const dialogue = [];
            let currentSpeaker = null;
            let speakerCount = 0;
            const speakerMap = {}; // Maps speaker names to 'alex' or 'sam' voice

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('|') ||
                    trimmed.startsWith('---') || trimmed.startsWith('*Next') || trimmed.startsWith('[Read')) {
                    continue;
                }

                // Match any speaker pattern: **NAME:** or **NAME:** text
                const speakerMatch = trimmed.match(/^\*\*([A-Z]+):\*\*\s*(.*)$/);
                const dirMatch = trimmed.match(/^\*?\*?\[(.+)\]\*?\*?$/);

                if (speakerMatch) {
                    const speakerName = speakerMatch[1];
                    const text = speakerMatch[2];

                    // Assign voice type (alternating between alex and sam voices)
                    if (!speakerMap[speakerName]) {
                        speakerMap[speakerName] = speakerCount % 2 === 0 ? 'alex' : 'sam';
                        speakerCount++;
                    }

                    const voiceType = speakerMap[speakerName];

                    if (text && text.trim()) {
                        dialogue.push({
                            speaker: speakerName,
                            text: cleanText(text),
                            type: voiceType
                        });
                    }
                    currentSpeaker = voiceType;
                } else if (dirMatch) {
                    // Stage directions like [MUSIC FADES] - skip these, don't speak them
                    // dialogue.push({ speaker: '', text: dirMatch[1], type: 'direction' });
                    continue;
                } else if (currentSpeaker && trimmed.length > 0 && !trimmed.startsWith('*') && !trimmed.startsWith('-')) {
                    // Continuation of previous speaker's text
                    if (dialogue.length > 0 && dialogue[dialogue.length - 1].type === currentSpeaker) {
                        dialogue[dialogue.length - 1].text += ' ' + cleanText(trimmed);
                    }
                }
            }
            return dialogue;
        }

        function cleanText(text) {
            return text.replace(/\*\*/g, '').replace(/\*/g, '').replace(/`/g, '')
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                .replace(/```[\s\S]*?```/g, 'code block').trim();
        }

        // ===== EPISODE LIST =====
        function renderEpisodeList(filter = '') {
            if (!currentPodcast || !currentPodcast.episodes) {
                document.getElementById('episode-list').innerHTML = '<p class="loading-text">No episodes found</p>';
                return;
            }

            const episodes = currentPodcast.episodes;
            const state = loadState();
            const listEl = document.getElementById('episode-list');
            listEl.innerHTML = '';

            const filterLower = filter.toLowerCase();
            let totalProgress = 0;
            let shown = 0;

            episodes.forEach(ep => {
                // Filter
                if (filter && !ep.title.toLowerCase().includes(filterLower) &&
                    !ep.subtitle.toLowerCase().includes(filterLower)) {
                    return;
                }
                shown++;

                const epKey = `${currentPodcast.id}-${ep.id}`;
                const progress = state.episodeProgress?.[epKey] || { percent: 0 };
                const isComplete = state.completedEpisodes?.includes(epKey);
                const inProgress = progress.percent > 0 && progress.percent < 98;

                totalProgress += isComplete ? 100 : progress.percent;

                const card = document.createElement('div');
                card.className = 'episode-card' + (isComplete ? ' completed' : '') + (inProgress ? ' in-progress' : '');
                card.innerHTML = `
                    <div class="ep-progress-bar" style="width: ${progress.percent}%"></div>
                    <div class="ep-header">
                        <span class="ep-number">EPISODE ${ep.id}</span>
                        ${isComplete ? '<span class="ep-status completed">Complete</span>' :
                          inProgress ? `<span class="ep-status in-progress">${progress.percent}%</span>` : ''}
                    </div>
                    <div class="ep-title">${ep.title}</div>
                    <div class="ep-subtitle">${ep.subtitle}</div>
                    <div class="ep-meta">
                        <span>~60 min</span>
                        ${progress.percent > 0 ? `<span>${Math.round((100 - progress.percent) * 0.6)} min left</span>` : ''}
                    </div>
                `;
                card.addEventListener('click', () => openEpisode(ep));
                listEl.appendChild(card);
            });

            // Update total progress badge
            const avgProgress = episodes.length > 0 ? Math.round(totalProgress / episodes.length) : 0;
            document.getElementById('total-progress-badge').textContent = `${avgProgress}% Complete`;
        }

        // Episode search
        document.getElementById('episode-search').addEventListener('input', e => {
            renderEpisodeList(e.target.value);
        });

        // ===== PLAYER =====
        async function openEpisode(episode) {
            currentEpisode = episode;
            dialogueLines = parseMarkdown(episode.content);
            chapters = parseChapters(episode.content);

            // Restore progress (with podcast-scoped key)
            const state = loadState();
            const epKey = currentPodcast ? `${currentPodcast.id}-${episode.id}` : episode.id;
            const progress = state.episodeProgress?.[epKey];
            currentLineIndex = progress?.line || 0;

            // Check for pre-generated audio
            await loadAudioManifest(episode);

            document.getElementById('player-episode-title').textContent = `Ep ${episode.id}: ${episode.title}`;

            // Set breadcrumb navigation
            const podcastName = currentPodcast ? currentPodcast.title : 'Podcast';
            document.getElementById('player-breadcrumb').textContent = `Home ‚Ä∫ ${podcastName} ‚Ä∫ Episode ${episode.id}`;

            renderTranscript();
            renderChapters();
            renderBookmarks();
            updateProgress();
            setStatus(useAudio ? 'Ready - High quality audio' : 'Ready - Tap play to start');

            document.getElementById('list-view').classList.remove('active');
            document.getElementById('player-view').classList.add('active');
            // Hide mini player when entering player view
            document.getElementById('mini-player').classList.remove('active');
        }

        // Load audio manifest for pre-generated audio
        async function loadAudioManifest(episode) {
            audioManifest = null;
            useAudio = false;
            audioSegmentDurations = [];
            totalAudioDuration = 0;

            if (!currentPodcast || !episode) return;

            // Construct manifest URL based on episode filename pattern
            const epNum = String(episode.id).padStart(2, '0');
            const epSlug = episode.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
            const manifestUrl = `/audio/${currentPodcast.id}/episode-${epNum}-${epSlug}/manifest.json`;

            try {
                const response = await fetch(manifestUrl);
                if (response.ok) {
                    audioManifest = await response.json();
                    useAudio = true;
                    console.log(`Loaded audio manifest: ${audioManifest.length} segments`);

                    // Load duration metadata for all segments
                    await loadAudioDurations(episode);
                }
            } catch (e) {
                // No audio available, will use TTS
                console.log('No pre-generated audio, using TTS');
            }
        }

        // Load duration metadata for audio segments
        async function loadAudioDurations(episode) {
            if (!audioManifest || audioManifest.length === 0) return;

            const epNum = String(episode.id).padStart(2, '0');
            const epSlug = episode.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');

            console.log('Loading audio durations...');
            const durationPromises = audioManifest.map((segment, index) => {
                return new Promise((resolve) => {
                    const audioUrl = `/audio/${currentPodcast.id}/episode-${epNum}-${epSlug}/${segment.file}`;
                    const audio = new Audio();
                    audio.preload = 'metadata';

                    audio.addEventListener('loadedmetadata', () => {
                        resolve({ index, duration: audio.duration });
                    });

                    audio.addEventListener('error', () => {
                        // If audio fails to load, estimate based on text length
                        // Roughly 150 words per minute, average 5 chars per word
                        const estimatedDuration = (segment.text.length / 5) / 150 * 60;
                        resolve({ index, duration: estimatedDuration });
                    });

                    audio.src = audioUrl;
                });
            });

            const results = await Promise.all(durationPromises);

            // Sort by index and extract durations
            results.sort((a, b) => a.index - b.index);
            audioSegmentDurations = results.map(r => r.duration);
            totalAudioDuration = audioSegmentDurations.reduce((sum, d) => sum + d, 0);

            console.log(`Loaded durations: ${totalAudioDuration.toFixed(0)}s total (${(totalAudioDuration/60).toFixed(1)} min)`);
        }

        document.getElementById('back-to-list').addEventListener('click', () => {
            saveState();
            document.getElementById('player-view').classList.remove('active');
            document.getElementById('list-view').classList.add('active');
            // Show mini player if still playing
            const showMini = currentPodcast && currentEpisode && (isPlaying || isPaused);
            document.getElementById('mini-player').classList.toggle('active', showMini);
            if (showMini) updateMiniPlayer();
            renderEpisodeList();
        });

        // Home button from player - go all the way back to podcasts list
        document.getElementById('home-from-player').addEventListener('click', () => {
            saveState();
            document.getElementById('player-view').classList.remove('active');
            document.getElementById('podcasts-view').classList.add('active');
            // Show mini player if still playing
            const showMini = currentPodcast && currentEpisode && (isPlaying || isPaused);
            document.getElementById('mini-player').classList.toggle('active', showMini);
            if (showMini) updateMiniPlayer();
            renderPodcastsList();
        });

        // ===== TRANSCRIPT =====
        function renderTranscript() {
            const content = document.getElementById('transcript-content');
            content.innerHTML = '';

            dialogueLines.forEach((line, index) => {
                const div = document.createElement('div');
                div.className = `transcript-line ${line.type}`;
                div.dataset.index = index;

                if (line.type === 'direction') {
                    div.innerHTML = `<div class="text">${line.text}</div>`;
                } else {
                    div.innerHTML = `<div class="speaker">${line.speaker}</div><div class="text">${line.text}</div>`;
                }
                div.addEventListener('click', () => jumpToLine(index));
                content.appendChild(div);
            });

            updateProgress();
        }

        function updateProgress() {
            const pct = dialogueLines.length > 0 ? (currentLineIndex / dialogueLines.length) * 100 : 0;
            document.getElementById('progress-fill').style.width = `${pct}%`;
            document.getElementById('current-pos').textContent = `Line ${currentLineIndex + 1}`;
            document.getElementById('total-pos').textContent = `of ${dialogueLines.length}`;

            // Calculate time remaining using actual audio durations or estimate
            const linesLeft = dialogueLines.length - currentLineIndex;
            let secondsLeft;

            if (audioSegmentDurations.length > 0 && currentLineIndex < audioSegmentDurations.length) {
                // Use actual audio durations for remaining segments
                const remainingDurations = audioSegmentDurations.slice(currentLineIndex);
                secondsLeft = remainingDurations.reduce((sum, d) => sum + d, 0) / speechRate;
            } else {
                // Fall back to estimated 3 seconds per line
                secondsLeft = (linesLeft * 3) / speechRate;
            }

            const minsLeft = Math.round(secondsLeft / 60);
            document.getElementById('time-remaining').textContent = `~${minsLeft} min left`;

            // Update highlighting
            document.querySelectorAll('.transcript-line').forEach((el, i) => {
                el.classList.toggle('current', i === currentLineIndex);
            });

            // Scroll into view
            const currentEl = document.querySelector('.transcript-line.current');
            if (currentEl) {
                currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            // Periodic save
            if (currentLineIndex % 10 === 0) {
                saveState();
            }

            // Update chapter indicator
            updateCurrentChapter();
        }

        // Transcript search
        function searchTranscript(query) {
            searchMatches = [];
            searchIndex = 0;

            document.querySelectorAll('.transcript-line').forEach(el => {
                el.classList.remove('search-match', 'search-current');
                const textEl = el.querySelector('.text');
                if (textEl) {
                    textEl.innerHTML = textEl.textContent; // Remove highlights
                }
            });

            if (!query) return;

            const queryLower = query.toLowerCase();
            dialogueLines.forEach((line, index) => {
                if (line.text.toLowerCase().includes(queryLower)) {
                    searchMatches.push(index);
                    const el = document.querySelector(`.transcript-line[data-index="${index}"]`);
                    if (el) {
                        el.classList.add('search-match');
                        const textEl = el.querySelector('.text');
                        if (textEl) {
                            const regex = new RegExp(`(${query})`, 'gi');
                            textEl.innerHTML = textEl.textContent.replace(regex, '<span class="highlight">$1</span>');
                        }
                    }
                }
            });

            if (searchMatches.length > 0) {
                highlightSearchResult(0);
            }
        }

        function highlightSearchResult(idx) {
            document.querySelectorAll('.transcript-line.search-current').forEach(el => {
                el.classList.remove('search-current');
            });

            if (searchMatches.length === 0) return;
            searchIndex = (idx + searchMatches.length) % searchMatches.length;

            const lineIdx = searchMatches[searchIndex];
            const el = document.querySelector(`.transcript-line[data-index="${lineIdx}"]`);
            if (el) {
                el.classList.add('search-current');
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        document.getElementById('transcript-search-input').addEventListener('input', e => {
            searchTranscript(e.target.value);
        });
        document.getElementById('search-prev').addEventListener('click', () => highlightSearchResult(searchIndex - 1));
        document.getElementById('search-next').addEventListener('click', () => highlightSearchResult(searchIndex + 1));

        // ===== PLAYBACK =====
        function setStatus(text, speaking = false) {
            document.getElementById('status-text').textContent = text;
            document.getElementById('status-dot').classList.toggle('speaking', speaking);
        }

        function speak(text, speaker) {
            // Use pre-generated audio if available
            if (useAudio && audioManifest && audioManifest[currentLineIndex]) {
                return speakWithAudio(currentLineIndex);
            }

            // Fall back to TTS
            return speakWithTTS(text, speaker);
        }

        function speakWithTTS(text, speaker) {
            return new Promise((resolve, reject) => {
                const utt = new SpeechSynthesisUtterance(text);
                if (speaker === 'alex' && alexVoice) utt.voice = alexVoice;
                else if (speaker === 'sam' && samVoice) utt.voice = samVoice;
                utt.rate = speechRate;
                utt.pitch = speaker === 'alex' ? 0.9 : 1.1;
                utt.onend = () => resolve();
                utt.onerror = (e) => reject(e);
                synth.speak(utt);
            });
        }

        function speakWithAudio(lineIndex) {
            return new Promise((resolve, reject) => {
                const segment = audioManifest[lineIndex];
                if (!segment) {
                    reject(new Error('No audio segment'));
                    return;
                }

                // Construct audio URL
                const epNum = String(currentEpisode.id).padStart(2, '0');
                const epSlug = currentEpisode.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/-+$/, '');
                const audioUrl = `/audio/${currentPodcast.id}/episode-${epNum}-${epSlug}/${segment.file}`;

                // Clean up previous audio element
                if (audioElement) {
                    audioElement.pause();
                    audioElement.src = '';
                }

                audioElement = new Audio(audioUrl);
                audioElement.playbackRate = speechRate;
                audioElement.preload = 'auto';

                // Enable background audio playback
                audioElement.setAttribute('playsinline', '');
                // Keep audio playing when screen locks
                audioElement.setAttribute('x-webkit-airplay', 'allow');
                // Prevent auto-pause on lock screen
                audioElement.preservesPitch = true;

                // Setup Web Audio API for voice boost if enabled
                if (voiceBoostEnabled && !audioContext) {
                    setupWebAudio();
                }

                // Handle when audio starts playing
                audioElement.onplay = () => {
                    console.log('Audio started playing');
                    updateMediaSession();
                };

                audioElement.onended = () => resolve();
                audioElement.onerror = (e) => {
                    console.warn('Audio playback failed, falling back to TTS');
                    // Fallback to TTS
                    speakWithTTS(segment.text, segment.speaker).then(resolve).catch(reject);
                };

                // Handle audio interruptions from other apps
                audioElement.addEventListener('pause', (e) => {
                    // Only handle if this was an external interruption (not user-initiated)
                    if (isPlaying && !isPaused && !document.hidden) {
                        console.log('Audio interrupted by another app');
                        isPaused = true;
                        document.getElementById('play-btn').textContent = '‚ñ∂';
                        setStatus('Paused (interrupted)');
                        updateMediaSession();
                    }
                });

                audioElement.play().catch(err => {
                    console.warn('Audio play failed:', err);
                    speakWithTTS(segment.text, segment.speaker).then(resolve).catch(reject);
                });
            });
        }

        async function startPlayback() {
            if (dialogueLines.length === 0) return;

            isPlaying = true;
            isPaused = false;
            document.getElementById('play-btn').textContent = '‚è∏';

            // Request wake lock to keep device awake during playback
            await requestWakeLock();

            while (currentLineIndex < dialogueLines.length && isPlaying) {
                // Check sleep timer
                if (sleepEndTime && Date.now() >= sleepEndTime) {
                    stopPlayback();
                    sleepEndTime = null;
                    updateSleepDisplay();
                    setStatus('Sleep timer ended');
                    break;
                }

                if (isPaused) {
                    await new Promise(r => setTimeout(r, 100));
                    continue;
                }

                const line = dialogueLines[currentLineIndex];
                updateProgress();
                setStatus(`${line.speaker || 'Narration'}: Speaking...`, true);

                try {
                    await speak(line.text, line.type);
                } catch (e) {
                    console.error('Speech error:', e);
                }

                if (isPlaying && !isPaused) {
                    currentLineIndex++;
                    await new Promise(r => setTimeout(r, 300));
                }
            }

            // Episode complete
            if (currentLineIndex >= dialogueLines.length && isPlaying) {
                isPlaying = false;
                isPaused = false;
                await releaseWakeLock();
                saveState();
                showCompleteModal();
            } else {
                isPlaying = false;
                isPaused = false;
                await releaseWakeLock();
                document.getElementById('play-btn').textContent = '‚ñ∂';
                setStatus('Ready');
            }
        }

        async function stopPlayback() {
            isPlaying = false;
            isPaused = false;
            synth.cancel();
            // Also stop audio if playing
            if (audioElement) {
                audioElement.pause();
                audioElement.src = '';
            }
            // Release wake lock when stopping playback
            await releaseWakeLock();
            document.getElementById('play-btn').textContent = '‚ñ∂';
            saveState();
        }

        function togglePlayPause() {
            if (!isPlaying) {
                startPlayback();
            } else if (isPaused) {
                isPaused = false;
                if (useAudio && audioElement) {
                    audioElement.play();
                } else {
                    synth.resume();
                }
                document.getElementById('play-btn').textContent = '‚è∏';
            } else {
                isPaused = true;
                if (useAudio && audioElement) {
                    audioElement.pause();
                } else {
                    synth.pause();
                }
                document.getElementById('play-btn').textContent = '‚ñ∂';
                setStatus('Paused');
                saveState();
            }
            updateMiniPlayer();
        }

        function jumpToLine(index, autoStart = false) {
            const wasPlaying = isPlaying && !isPaused;
            // Stop any current playback cleanly
            isPlaying = false;
            isPaused = false;
            synth.cancel();
            // Also stop audio if playing
            if (audioElement) {
                audioElement.pause();
                audioElement.src = '';
            }

            currentLineIndex = Math.max(0, Math.min(index, dialogueLines.length - 1));
            updateProgress();
            saveState();

            // Update UI
            document.getElementById('play-btn').textContent = '‚ñ∂';
            setStatus('Ready');

            // Auto-start if requested or was playing before
            if (autoStart || wasPlaying) {
                setTimeout(() => startPlayback(), 100);
            }
        }

        function skipLines(n) {
            jumpToLine(currentLineIndex + n, isPlaying && !isPaused);
        }

        // Controls
        document.getElementById('play-btn').addEventListener('click', togglePlayPause);
        document.getElementById('prev-btn').addEventListener('click', () => skipLines(-10));
        document.getElementById('next-btn').addEventListener('click', () => skipLines(10));
        document.getElementById('back-btn').addEventListener('click', () => skipLines(-5));
        document.getElementById('fwd-btn').addEventListener('click', () => skipLines(5));

        // Speed
        document.getElementById('speed-slider').addEventListener('input', e => {
            speechRate = parseFloat(e.target.value);
            document.getElementById('speed-value').textContent = `${speechRate.toFixed(1)}x`;
            // Update audio playback rate if using audio
            if (useAudio && audioElement) {
                audioElement.playbackRate = speechRate;
            }
            // Update speed preset button highlights
            document.querySelectorAll('.speed-preset-btn').forEach(b => {
                b.classList.toggle('active', Math.abs(parseFloat(b.dataset.speed) - speechRate) < 0.01);
            });
            saveState();
        });

        // Progress bar click
        document.getElementById('progress-bar').addEventListener('click', e => {
            const rect = e.target.getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            const wasPlaying = isPlaying && !isPaused;
            jumpToLine(Math.floor(pct * dialogueLines.length), wasPlaying);
        });

        // Auto-play toggle
        document.getElementById('auto-play-toggle').addEventListener('click', () => {
            autoPlayNext = !autoPlayNext;
            document.getElementById('auto-play-toggle').classList.toggle('active', autoPlayNext);
            saveState();
        });

        // ===== SLEEP TIMER =====
        document.getElementById('sleep-timer-btn').addEventListener('click', () => {
            document.getElementById('sleep-modal').classList.add('show');
        });

        document.getElementById('close-sleep-modal').addEventListener('click', () => {
            document.getElementById('sleep-modal').classList.remove('show');
        });

        document.querySelectorAll('.timer-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.timer-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const mins = parseInt(btn.dataset.minutes);
                sleepEndTime = Date.now() + mins * 60 * 1000;
                updateSleepDisplay();
            });
        });

        document.getElementById('cancel-timer').addEventListener('click', () => {
            sleepEndTime = null;
            document.querySelectorAll('.timer-btn').forEach(b => b.classList.remove('active'));
            updateSleepDisplay();
        });

        function updateSleepDisplay() {
            const display = document.getElementById('timer-display');
            if (sleepEndTime) {
                const minsLeft = Math.max(0, Math.round((sleepEndTime - Date.now()) / 60000));
                display.textContent = `Stopping in ${minsLeft} minutes`;
                display.classList.add('active');
            } else {
                display.textContent = 'No timer set';
                display.classList.remove('active');
            }
        }

        // Update timer display every minute
        setInterval(updateSleepDisplay, 60000);

        // ===== EPISODE COMPLETE MODAL =====
        function showCompleteModal() {
            document.getElementById('play-btn').textContent = '‚ñ∂';
            setStatus('Episode complete! üéâ');

            const episodes = currentPodcast?.episodes || [];
            const nextEp = episodes.find(e => e.id === currentEpisode.id + 1);

            if (autoPlayNext && nextEp) {
                document.getElementById('complete-message').textContent = `Starting "${nextEp.title}" in 5 seconds...`;
                document.getElementById('play-next-episode').textContent = 'Play Now';
                document.getElementById('complete-modal').classList.add('show');

                setTimeout(() => {
                    if (document.getElementById('complete-modal').classList.contains('show')) {
                        playNextEpisode();
                    }
                }, 5000);
            } else if (nextEp) {
                document.getElementById('complete-message').textContent = `Up next: "${nextEp.title}"`;
                document.getElementById('play-next-episode').textContent = 'Play Next Episode';
                document.getElementById('complete-modal').classList.add('show');
            } else {
                document.getElementById('complete-message').textContent = 'You\'ve completed all episodes! üèÜ';
                document.getElementById('play-next-episode').style.display = 'none';
                document.getElementById('complete-modal').classList.add('show');
            }
        }

        function playNextEpisode() {
            document.getElementById('complete-modal').classList.remove('show');
            const episodes = currentPodcast?.episodes || [];
            const nextEp = episodes.find(e => e.id === currentEpisode.id + 1);
            if (nextEp) {
                openEpisode(nextEp);
                setTimeout(() => startPlayback(), 500);
            }
        }

        function playPreviousEpisode() {
            const episodes = currentPodcast?.episodes || [];
            const prevEp = episodes.find(e => e.id === currentEpisode.id - 1);
            if (prevEp) {
                stopPlayback();
                openEpisode(prevEp);
                setTimeout(() => startPlayback(), 500);
            }
        }

        document.getElementById('play-next-episode').addEventListener('click', playNextEpisode);
        document.getElementById('back-to-episodes').addEventListener('click', () => {
            document.getElementById('complete-modal').classList.remove('show');
            document.getElementById('back-to-list').click();
        });

        // ===== SWIPE GESTURES =====
        let touchStartX = 0;
        let touchStartY = 0;
        const swipeThreshold = 80;

        document.getElementById('player-view').addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        document.getElementById('player-view').addEventListener('touchmove', e => {
            if (!touchStartX) return;
            const diffX = e.touches[0].clientX - touchStartX;
            const diffY = Math.abs(e.touches[0].clientY - touchStartY);

            // Only show hint if horizontal swipe
            if (Math.abs(diffX) > 30 && diffY < 50) {
                if (diffX > 0) {
                    document.getElementById('swipe-left').classList.add('show');
                    document.getElementById('swipe-right').classList.remove('show');
                } else {
                    document.getElementById('swipe-right').classList.add('show');
                    document.getElementById('swipe-left').classList.remove('show');
                }
            }
        }, { passive: true });

        document.getElementById('player-view').addEventListener('touchend', e => {
            document.getElementById('swipe-left').classList.remove('show');
            document.getElementById('swipe-right').classList.remove('show');

            if (!touchStartX) return;
            const diffX = e.changedTouches[0].clientX - touchStartX;
            const diffY = Math.abs(e.changedTouches[0].clientY - touchStartY);

            if (Math.abs(diffX) > swipeThreshold && diffY < 50) {
                if (diffX > 0) {
                    skipLines(-10); // Swipe right = go back
                } else {
                    skipLines(10); // Swipe left = go forward
                }
            }
            touchStartX = 0;
        }, { passive: true });

        // ===== COLLAPSIBLE PANELS =====
        document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                header.parentElement.classList.toggle('collapsed');
            });
        });

        // ===== INSTALL PROMPT =====
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', e => {
            e.preventDefault();
            deferredPrompt = e;
            document.getElementById('install-modal').classList.add('show');
        });

        document.getElementById('do-install').addEventListener('click', () => {
            document.getElementById('install-modal').classList.remove('show');
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then(() => { deferredPrompt = null; });
            }
        });

        document.getElementById('dismiss-install').addEventListener('click', () => {
            document.getElementById('install-modal').classList.remove('show');
        });

        // ===== NEW FEATURES =====

        // Initialize theme
        if (currentTheme === 'light') {
            document.body.classList.add('light-theme');
        }

        // Speed Presets
        document.querySelectorAll('.speed-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const speed = parseFloat(btn.dataset.speed);
                speechRate = speed;
                document.getElementById('speed-slider').value = speed;
                document.getElementById('speed-value').textContent = `${speed.toFixed(1)}x`;
                if (useAudio && audioElement) {
                    audioElement.playbackRate = speed;
                }
                document.querySelectorAll('.speed-preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                saveState();
            });
        });

        // Theme Toggle
        document.getElementById('theme-toggle').addEventListener('click', () => {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.classList.toggle('light-theme');
            document.getElementById('theme-toggle').querySelector('span').textContent =
                currentTheme === 'dark' ? 'üåô Dark' : '‚òÄÔ∏è Light';
            localStorage.setItem('theme', currentTheme);
        });

        // Settings Panel
        document.getElementById('skip-forward-interval').addEventListener('change', e => {
            skipForwardInterval = parseInt(e.target.value);
            localStorage.setItem('skipForwardInterval', skipForwardInterval);
            updateSkipButtonTitles();
        });

        document.getElementById('skip-backward-interval').addEventListener('change', e => {
            skipBackwardInterval = parseInt(e.target.value);
            localStorage.setItem('skipBackwardInterval', skipBackwardInterval);
            updateSkipButtonTitles();
        });

        function updateSkipButtonTitles() {
            document.getElementById('next-btn').title = `Forward ${skipForwardInterval}s`;
            document.getElementById('prev-btn').title = `Back ${skipBackwardInterval}s`;
        }

        // Voice Boost Toggle
        document.getElementById('voice-boost-toggle').addEventListener('click', () => {
            voiceBoostEnabled = !voiceBoostEnabled;
            document.getElementById('voice-boost-toggle').classList.toggle('active', voiceBoostEnabled);
            document.getElementById('voice-boost-toggle').querySelector('span').textContent =
                voiceBoostEnabled ? 'On' : 'Off';
            localStorage.setItem('voiceBoostEnabled', voiceBoostEnabled);
            if (voiceBoostEnabled && audioElement && !audioContext) {
                setupWebAudio();
            }
        });

        // Silence Trim Toggle
        document.getElementById('silence-trim-toggle').addEventListener('click', () => {
            silenceTrimEnabled = !silenceTrimEnabled;
            document.getElementById('silence-trim-toggle').classList.toggle('active', silenceTrimEnabled);
            document.getElementById('silence-trim-toggle').querySelector('span').textContent =
                silenceTrimEnabled ? 'On' : 'Off';
            localStorage.setItem('silenceTrimEnabled', silenceTrimEnabled);
        });

        // Episode Filters
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                currentFilter = btn.dataset.filter;
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                filterAndSortEpisodes();
            });
        });

        document.getElementById('episode-sort').addEventListener('change', e => {
            currentSort = e.target.value;
            filterAndSortEpisodes();
        });

        function filterAndSortEpisodes() {
            if (!currentPodcast) return;
            const container = document.getElementById('episode-list');
            const cards = Array.from(container.querySelectorAll('.episode-card'));

            // Filter
            cards.forEach(card => {
                const status = card.classList.contains('completed') ? 'completed' :
                              card.classList.contains('in-progress') ? 'in-progress' : 'unplayed';
                const show = currentFilter === 'all' ||
                            (currentFilter === 'completed' && status === 'completed') ||
                            (currentFilter === 'in-progress' && status === 'in-progress') ||
                            (currentFilter === 'unplayed' && status === 'unplayed');
                card.style.display = show ? '' : 'none';
            });

            // Sort
            if (currentSort !== 'default') {
                const sortedCards = cards.sort((a, b) => {
                    const aNum = parseInt(a.querySelector('.ep-number').textContent.match(/\d+/)[0]);
                    const bNum = parseInt(b.querySelector('.ep-number').textContent.match(/\d+/)[0]);
                    const aTitle = a.querySelector('.ep-title').textContent;
                    const bTitle = b.querySelector('.ep-title').textContent;
                    const aProgress = parseFloat(a.querySelector('.ep-progress-bar').style.width) || 0;
                    const bProgress = parseFloat(b.querySelector('.ep-progress-bar').style.width) || 0;

                    switch(currentSort) {
                        case 'newest': return bNum - aNum;
                        case 'oldest': return aNum - bNum;
                        case 'title': return aTitle.localeCompare(bTitle);
                        case 'progress': return bProgress - aProgress;
                        default: return 0;
                    }
                });
                sortedCards.forEach(card => container.appendChild(card));
            }
        }

        // Queue Management
        function addToQueue(podcast, episode) {
            playQueue.push({ podcastId: podcast.id, episodeNum: episode.id, addedAt: Date.now() });
            localStorage.setItem('playQueue', JSON.stringify(playQueue));
            updateQueueDisplay();
        }

        function removeFromQueue(index) {
            playQueue.splice(index, 1);
            localStorage.setItem('playQueue', JSON.stringify(playQueue));
            updateQueueDisplay();
        }

        function updateQueueDisplay() {
            const queueList = document.getElementById('queue-list');
            if (playQueue.length === 0) {
                queueList.innerHTML = '<div class="no-items">Queue is empty</div>';
                return;
            }

            queueList.innerHTML = playQueue.map((item, index) => {
                const podcast = PODCASTS?.find(p => p.id === item.podcastId);
                const episode = podcast?.episodes.find(e => e.id === item.episodeNum);
                if (!podcast || !episode) return '';

                const isPlaying = currentPodcast?.id === item.podcastId && currentEpisode?.id === item.episodeNum;

                return `
                    <div class="queue-item ${isPlaying ? 'playing' : ''}" data-index="${index}">
                        <div class="queue-number">${index + 1}</div>
                        <div class="queue-info">
                            <div class="queue-title">${episode.title}</div>
                            <div class="queue-subtitle">${podcast.name}</div>
                        </div>
                        <button class="queue-remove" data-index="${index}">√ó</button>
                    </div>
                `;
            }).join('');

            // Add click handlers
            queueList.querySelectorAll('.queue-item').forEach((item, index) => {
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('queue-remove')) {
                        const queueItem = playQueue[index];
                        const podcast = PODCASTS.find(p => p.id === queueItem.podcastId);
                        const episode = podcast.episodes.find(e => e.id === queueItem.episodeNum);
                        openPodcast(podcast);
                        setTimeout(() => openEpisode(episode), 100);
                    }
                });
            });

            queueList.querySelectorAll('.queue-remove').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeFromQueue(parseInt(btn.dataset.index));
                });
            });
        }

        // Nav tabs for queue
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.dataset.tab;
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.querySelectorAll('.nav-content').forEach(content => {
                    content.classList.toggle('active', content.dataset.tab === targetTab);
                });
                if (targetTab === 'queue') {
                    updateQueueDisplay();
                }
            });
        });

        // Share & Export
        document.getElementById('share-btn').addEventListener('click', () => {
            document.getElementById('share-modal').classList.add('show');
        });

        document.getElementById('close-share-modal').addEventListener('click', () => {
            document.getElementById('share-modal').classList.remove('show');
        });

        document.getElementById('share-timestamp-btn').addEventListener('click', () => {
            const url = new URL(window.location.href);
            url.searchParams.set('podcast', currentPodcast.id);
            url.searchParams.set('episode', currentEpisode.id);
            url.searchParams.set('line', currentLineIndex);

            if (navigator.share) {
                navigator.share({
                    title: `${currentEpisode.title} - ${currentPodcast.name}`,
                    text: `Listen from line ${currentLineIndex}`,
                    url: url.toString()
                });
            } else {
                navigator.clipboard.writeText(url.toString());
                alert('Link copied to clipboard!');
            }
        });

        document.getElementById('share-episode-btn').addEventListener('click', () => {
            const url = new URL(window.location.href);
            url.searchParams.set('podcast', currentPodcast.id);
            url.searchParams.set('episode', currentEpisode.id);

            if (navigator.share) {
                navigator.share({
                    title: `${currentEpisode.title} - ${currentPodcast.name}`,
                    text: currentEpisode.subtitle,
                    url: url.toString()
                });
            } else {
                navigator.clipboard.writeText(url.toString());
                alert('Link copied to clipboard!');
            }
        });

        document.getElementById('export-bookmarks-btn').addEventListener('click', () => {
            const bookmarks = JSON.parse(localStorage.getItem(`bookmarks-${currentPodcast.id}-${currentEpisode.id}`) || '[]');
            const data = {
                podcast: currentPodcast.name,
                episode: currentEpisode.title,
                bookmarks: bookmarks.map(b => ({
                    line: b.line,
                    note: b.note,
                    context: b.context
                }))
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bookmarks-${currentPodcast.id}-${currentEpisode.id}.json`;
            a.click();
        });

        document.getElementById('export-progress-btn').addEventListener('click', () => {
            const allProgress = {};
            for (let key in localStorage) {
                if (key.startsWith('state-')) {
                    allProgress[key] = JSON.parse(localStorage[key]);
                }
            }
            const blob = new Blob([JSON.stringify(allProgress, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'podcast-progress.json';
            a.click();
        });

        // Statistics
        document.getElementById('stats-btn').addEventListener('click', () => {
            updateStatisticsDisplay();
            document.getElementById('stats-modal').classList.add('show');
        });

        document.getElementById('close-stats-modal').addEventListener('click', () => {
            document.getElementById('stats-modal').classList.remove('show');
        });

        function updateListeningStats(secondsListened) {
            listeningStats.totalTime += secondsListened;
            listeningStats.speedSum += speechRate;
            listeningStats.speedCount += 1;

            const today = new Date().toDateString();
            if (listeningStats.lastListenDate !== today) {
                if (listeningStats.lastListenDate === new Date(Date.now() - 86400000).toDateString()) {
                    listeningStats.currentStreak += 1;
                } else {
                    listeningStats.currentStreak = 1;
                }
                listeningStats.lastListenDate = today;
            }

            localStorage.setItem('listeningStats', JSON.stringify(listeningStats));
        }

        function updateStatisticsDisplay() {
            const hours = Math.floor(listeningStats.totalTime / 3600);
            const mins = Math.floor((listeningStats.totalTime % 3600) / 60);
            document.getElementById('stat-total-time').textContent = `${hours}h ${mins}m`;
            document.getElementById('stat-episodes-completed').textContent = listeningStats.episodesCompleted;
            document.getElementById('stat-current-streak').textContent = listeningStats.currentStreak;

            const avgSpeed = listeningStats.speedCount > 0 ?
                (listeningStats.speedSum / listeningStats.speedCount).toFixed(1) : '1.0';
            document.getElementById('stat-avg-speed').textContent = avgSpeed + 'x';

            const normalTime = listeningStats.totalTime * (parseFloat(avgSpeed));
            const timeSaved = normalTime - listeningStats.totalTime;
            const savedHours = Math.floor(timeSaved / 3600);
            const savedMins = Math.floor((timeSaved % 3600) / 60);
            document.getElementById('stat-time-saved').textContent = `${savedHours}h ${savedMins}m`;
        }

        // Track time listened
        let lastStatsUpdate = Date.now();
        setInterval(() => {
            if (isPlaying && !isPaused) {
                const now = Date.now();
                const elapsed = (now - lastStatsUpdate) / 1000;
                updateListeningStats(elapsed);
                lastStatsUpdate = now;
            }
        }, 10000); // Update every 10 seconds

        // Mini Player
        function updateMiniPlayer() {
            if (currentPodcast && currentEpisode) {
                document.getElementById('mini-player-title').textContent = currentEpisode.title;
                document.getElementById('mini-player-subtitle').textContent = currentPodcast.name;
                document.getElementById('mini-play-btn').textContent = (isPlaying && !isPaused) ? '‚è∏' : '‚ñ∂';
            }
        }

        document.getElementById('mini-player').addEventListener('click', (e) => {
            if (!e.target.classList.contains('mini-ctrl-btn') && currentPodcast && currentEpisode) {
                showView('player-view');
            }
        });

        document.getElementById('mini-play-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            togglePlayPause();
        });

        // Web Audio API Setup
        function setupWebAudio() {
            if (audioContext && audioSource) {
                // Already set up, just update gain
                if (gainNode) {
                    gainNode.gain.value = voiceBoostEnabled ? 1.3 : 1.0;
                }
                return;
            }

            if (!audioElement || !voiceBoostEnabled) return;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioSource = audioContext.createMediaElementSource(audioElement);
                gainNode = audioContext.createGain();
                analyser = audioContext.createAnalyser();

                // Voice boost: increase mid-range frequencies
                gainNode.gain.value = 1.3;

                audioSource.connect(gainNode);
                gainNode.connect(analyser);
                analyser.connect(audioContext.destination);

                console.log('Web Audio API initialized with voice boost');
            } catch (e) {
                console.error('Web Audio API setup failed:', e);
                // Reset state on failure
                audioContext = null;
                audioSource = null;
                gainNode = null;
                analyser = null;
            }
        }

        // Load from URL parameters
        window.addEventListener('load', () => {
            const params = new URLSearchParams(window.location.search);
            const podcastId = params.get('podcast');
            const episodeNum = params.get('episode');
            const lineNum = params.get('line');

            if (podcastId && PODCASTS) {
                const podcast = PODCASTS.find(p => p.id === podcastId);
                if (podcast && episodeNum) {
                    const episode = podcast.episodes.find(e => e.id === parseInt(episodeNum));
                    if (episode) {
                        openPodcast(podcast);
                        setTimeout(() => {
                            openEpisode(episode);
                            if (lineNum) {
                                setTimeout(() => {
                                    jumpToLine(parseInt(lineNum), false);
                                }, 500);
                            }
                        }, 100);
                    }
                }
            }
        });

        // Initialize settings
        document.getElementById('skip-forward-interval').value = skipForwardInterval;
        document.getElementById('skip-backward-interval').value = skipBackwardInterval;
        if (voiceBoostEnabled) {
            document.getElementById('voice-boost-toggle').classList.add('active');
            document.getElementById('voice-boost-toggle').querySelector('span').textContent = 'On';
        }
        if (silenceTrimEnabled) {
            document.getElementById('silence-trim-toggle').classList.add('active');
            document.getElementById('silence-trim-toggle').querySelector('span').textContent = 'On';
        }
        updateSkipButtonTitles();
        updateQueueDisplay();

        // ===== CHAPTERS =====
        let chapters = [];

        function parseChapters(content) {
            const lines = content.split('\n');
            const chaps = [];
            let currentLine = 0;
            let dialogueLine = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                // Track dialogue lines for position mapping (any speaker name pattern: **NAME:** or **NAME:**)
                if (line.match(/^\*\*[A-Z]+:\*\*/)) {
                    // Check if this line follows a chapter header
                    for (let j = chaps.length - 1; j >= 0; j--) {
                        if (chaps[j].lineIndex === -1) {
                            chaps[j].lineIndex = dialogueLine;
                            break;
                        }
                    }
                    dialogueLine++;
                }

                // Find chapter headers (### SEGMENT, ### INTRO, etc.)
                const chapterMatch = line.match(/^###\s+(.+)/);
                if (chapterMatch) {
                    let title = chapterMatch[1].trim();
                    // Clean up the title
                    title = title.replace(/\*\*/g, '').replace(/\(\d+\s*minutes?\)/i, '').trim();
                    title = title.replace(/:\s*$/, '');

                    chaps.push({
                        title: title,
                        lineIndex: -1, // Will be set when we find the next dialogue
                        rawLine: i
                    });
                }
            }

            // Assign line index to any remaining chapters
            chaps.forEach((chap, idx) => {
                if (chap.lineIndex === -1) {
                    chap.lineIndex = idx === 0 ? 0 : dialogueLine;
                }
            });

            // Add estimated times based on actual audio duration or line count
            let avgSecsPerLine = 3;  // default fallback

            // If we have actual audio durations, calculate accurate average
            if (audioSegmentDurations.length > 0 && dialogueLine > 0) {
                avgSecsPerLine = totalAudioDuration / dialogueLine;
                console.log(`Using actual duration: ${avgSecsPerLine.toFixed(2)}s per line`);
            } else {
                console.log('Using estimated duration: 3s per line');
            }

            chaps.forEach((chap, idx) => {
                const nextChap = chaps[idx + 1];
                const endLine = nextChap ? nextChap.lineIndex : dialogueLine;
                const lines = endLine - chap.lineIndex;

                // Calculate duration in minutes
                let mins = Math.round((lines * avgSecsPerLine) / 60);

                // If using actual audio durations, calculate precise segment duration
                if (audioSegmentDurations.length > 0) {
                    const segmentDuration = audioSegmentDurations.slice(chap.lineIndex, endLine)
                        .reduce((sum, d) => sum + d, 0);
                    mins = Math.round(segmentDuration / 60);
                }

                chap.duration = mins > 0 ? mins : 1;  // minimum 1 minute
            });

            return chaps;
        }

        function renderChapters() {
            const container = document.getElementById('chapters-list');
            container.innerHTML = '';

            if (chapters.length === 0) {
                container.innerHTML = '<div class="no-items">No chapters found</div>';
                return;
            }

            chapters.forEach((chap, idx) => {
                const item = document.createElement('div');
                item.className = 'chapter-item';
                item.dataset.index = idx;

                item.innerHTML = `
                    <div class="chapter-number">${idx + 1}</div>
                    <div class="chapter-info">
                        <div class="chapter-title">${chap.title}</div>
                        <div class="chapter-time">~${chap.duration} min</div>
                    </div>
                `;

                item.addEventListener('click', () => {
                    jumpToLine(chap.lineIndex, true);
                });

                container.appendChild(item);
            });

            updateCurrentChapter();
        }

        function updateCurrentChapter() {
            // Find current chapter based on line
            let currentChapIdx = 0;
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (currentLineIndex >= chapters[i].lineIndex) {
                    currentChapIdx = i;
                    break;
                }
            }

            // Update chapter list highlighting
            document.querySelectorAll('.chapter-item').forEach((el, idx) => {
                el.classList.toggle('current', idx === currentChapIdx);
            });

            // Update badge
            if (chapters.length > 0 && chapters[currentChapIdx]) {
                document.getElementById('current-chapter-badge').textContent =
                    `Chapter ${currentChapIdx + 1}: ${chapters[currentChapIdx].title}`;
            } else {
                document.getElementById('current-chapter-badge').textContent = '';
            }
        }

        // ===== BOOKMARKS =====
        function getBookmarks() {
            const state = loadState();
            return state.bookmarks || {};
        }

        function getEpisodeKey() {
            return currentPodcast && currentEpisode ? `${currentPodcast.id}-${currentEpisode.id}` : null;
        }

        function saveBookmark(epKey, lineIndex, note) {
            const state = loadState();
            if (!state.bookmarks) state.bookmarks = {};
            if (!state.bookmarks[epKey]) state.bookmarks[epKey] = [];

            state.bookmarks[epKey].push({
                lineIndex,
                note: note || '',
                timestamp: Date.now()
            });

            // Sort by line index
            state.bookmarks[epKey].sort((a, b) => a.lineIndex - b.lineIndex);

            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function deleteBookmark(epKey, timestamp) {
            const state = loadState();
            if (state.bookmarks && state.bookmarks[epKey]) {
                state.bookmarks[epKey] = state.bookmarks[epKey].filter(b => b.timestamp !== timestamp);
            }
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function renderBookmarks() {
            const container = document.getElementById('bookmarks-list');
            container.innerHTML = '';

            // Add bookmark button first
            const addBtn = document.createElement('button');
            addBtn.className = 'add-bookmark-btn';
            addBtn.id = 'add-bookmark-btn';
            addBtn.textContent = '+ Add Bookmark Here';
            addBtn.addEventListener('click', showAddBookmarkModal);
            container.appendChild(addBtn);

            const epKey = getEpisodeKey();
            if (!epKey) return;

            const bookmarks = getBookmarks();
            const epBookmarks = bookmarks[epKey] || [];

            if (epBookmarks.length === 0) {
                container.innerHTML += '<div class="no-items">No bookmarks yet</div>';
                return;
            }

            epBookmarks.forEach(bm => {
                const item = document.createElement('div');
                item.className = 'bookmark-item';

                // Get preview text from dialogue
                const line = dialogueLines[bm.lineIndex];
                const preview = line ? line.text.substring(0, 60) + (line.text.length > 60 ? '...' : '') : '';

                item.innerHTML = `
                    <div class="bookmark-content">
                        <div class="bookmark-position">Line ${bm.lineIndex + 1}</div>
                        <div class="bookmark-note">${bm.note || 'Bookmark'}</div>
                        <div class="bookmark-preview">${preview}</div>
                    </div>
                    <button class="bookmark-delete" data-ts="${bm.timestamp}">√ó</button>
                `;

                item.querySelector('.bookmark-content').addEventListener('click', () => {
                    jumpToLine(bm.lineIndex, true);
                });

                item.querySelector('.bookmark-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteBookmark(epKey, bm.timestamp);
                    renderBookmarks();
                });

                container.appendChild(item);
            });
        }

        function showAddBookmarkModal() {
            const modal = document.getElementById('bookmark-modal');
            document.getElementById('bookmark-position-text').textContent =
                `Line ${currentLineIndex + 1} of ${dialogueLines.length}`;

            const line = dialogueLines[currentLineIndex];
            document.getElementById('bookmark-context').textContent =
                line ? `${line.speaker ? line.speaker + ': ' : ''}${line.text.substring(0, 100)}...` : '';

            document.getElementById('bookmark-note-input').value = '';
            modal.classList.add('show');
            document.getElementById('bookmark-note-input').focus();
        }

        document.getElementById('save-bookmark').addEventListener('click', () => {
            const epKey = getEpisodeKey();
            if (!epKey) return;
            const note = document.getElementById('bookmark-note-input').value;
            saveBookmark(epKey, currentLineIndex, note);
            document.getElementById('bookmark-modal').classList.remove('show');
            renderBookmarks();
        });

        document.getElementById('cancel-bookmark').addEventListener('click', () => {
            document.getElementById('bookmark-modal').classList.remove('show');
        });

        // Tab switching
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;

                // Update tab buttons
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update content
                document.querySelectorAll('.nav-content').forEach(c => c.classList.remove('active'));
                document.querySelector(`.nav-content[data-tab="${tabName}"]`).classList.add('active');
            });
        });

        // ===== INIT =====
        restoreState();
        renderPodcastsList();

        // Service worker registration with update handling
        let swRegistration = null;

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('SW registered');
                swRegistration = reg;
                document.getElementById('offline-badge-home').style.display = 'inline-flex';
                document.getElementById('offline-badge').style.display = 'inline-flex';

                // Check for updates periodically
                setInterval(() => reg.update(), 60000);

                // Listen for new service worker
                reg.addEventListener('updatefound', () => {
                    const newWorker = reg.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // New content available
                            document.getElementById('update-banner').style.display = 'flex';
                        }
                    });
                });
            }).catch(err => console.log('SW error:', err));

            // Listen for SW messages
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data.type === 'SW_UPDATED') {
                    console.log('SW updated to:', event.data.version);
                    // Reload to get fresh content
                    window.location.reload();
                }
            });

            // Handle controller change (new SW took over)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('New SW controller, reloading...');
                window.location.reload();
            });
        }

        // ===== BACKGROUND MODE HANDLING =====
        // Track playback state before going to background
        let wasPlayingBeforeBackground = false;
        let backgroundHandlersEnabled = false;

        // Enable background handlers after a short delay to avoid interfering with initial load
        setTimeout(() => {
            backgroundHandlersEnabled = true;
            console.log('Background mode handlers enabled');
        }, 1000);

        // Handle visibility changes (tab switching, minimizing)
        document.addEventListener('visibilitychange', async () => {
            if (!backgroundHandlersEnabled) return;

            if (document.hidden) {
                // App went to background - continue playing audio
                console.log('App went to background, isPlaying:', isPlaying, 'isPaused:', isPaused);
                wasPlayingBeforeBackground = isPlaying && !isPaused;

                // Save current state but DO NOT pause - allow background playback
                saveState();
                console.log('Audio will continue playing in background');
            } else {
                // App came to foreground
                console.log('App came to foreground, wasPlaying:', wasPlayingBeforeBackground);

                // Re-acquire wake lock if playback is active
                if (isPlaying && !isPaused) {
                    await requestWakeLock();

                    // Resume audio if it was paused by system
                    if (useAudio && audioElement && audioElement.paused) {
                        console.log('Resuming audio playback after background');
                        audioElement.play().catch(err => {
                            console.warn('Failed to resume audio:', err);
                        });
                    }

                    // Resume speech synthesis if it was paused
                    if (!useAudio && synth.paused) {
                        console.log('Resuming speech synthesis after background');
                        synth.resume();
                    }
                }
            }
        }, { passive: true });

        // Handle page hide event (navigating away, closing tab)
        window.addEventListener('pagehide', (e) => {
            if (!backgroundHandlersEnabled) return;

            console.log('Page hide - saving state, persisted:', e.persisted);
            saveState();

            // Don't cancel speech/audio - allow background playback to continue
            // Audio elements and Media Session API will handle background playback
            console.log('Page hidden, audio continues in background');
        }, { passive: true });

        // Fallback: beforeunload for saving state
        window.addEventListener('beforeunload', () => {
            if (!backgroundHandlersEnabled) return;
            console.log('Before unload - saving state');
            saveState();
        });

        // Force refresh - clears cache and reloads
        function forceRefresh() {
            const btn = document.getElementById('refresh-btn');
            btn.textContent = '‚Üª Refreshing...';
            btn.disabled = true;

            // Clear caches
            if ('caches' in window) {
                caches.keys().then(names => {
                    return Promise.all(names.map(name => caches.delete(name)));
                }).then(() => {
                    console.log('All caches cleared');
                    // Unregister service worker and reload
                    if (swRegistration) {
                        swRegistration.unregister().then(() => {
                            window.location.reload(true);
                        });
                    } else {
                        window.location.reload(true);
                    }
                });
            } else {
                window.location.reload(true);
            }
        }

        // Apply pending update
        function applyUpdate() {
            if (swRegistration && swRegistration.waiting) {
                swRegistration.waiting.postMessage('SKIP_WAITING');
            }
            window.location.reload();
        }

        // ===== MEDIA SESSION API =====
        // Enables lock screen controls, notification controls, and handles audio interruptions
        function updateMediaSession() {
            if (!('mediaSession' in navigator)) {
                console.log('Media Session API not supported');
                return;
            }

            if (!currentPodcast || !currentEpisode) {
                return;
            }

            // Update metadata
            navigator.mediaSession.metadata = new MediaMetadata({
                title: currentEpisode.title,
                artist: currentPodcast.title,
                album: 'PodLearn',
                artwork: [
                    { src: '/icon.svg', sizes: '512x512', type: 'image/svg+xml' }
                ]
            });

            // Set up action handlers
            navigator.mediaSession.setActionHandler('play', () => {
                if (!isPlaying || isPaused) {
                    togglePlayPause();
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                if (isPlaying && !isPaused) {
                    togglePlayPause();
                }
            });

            navigator.mediaSession.setActionHandler('seekbackward', () => {
                // Jump back 10 seconds worth of lines
                const newIndex = Math.max(0, currentLineIndex - 5);
                jumpToLine(newIndex);
            });

            navigator.mediaSession.setActionHandler('seekforward', () => {
                // Jump forward 10 seconds worth of lines
                const newIndex = Math.min(dialogueLines.length - 1, currentLineIndex + 5);
                jumpToLine(newIndex);
            });

            navigator.mediaSession.setActionHandler('previoustrack', () => {
                // Navigate to previous episode
                playPreviousEpisode();
            });

            navigator.mediaSession.setActionHandler('nexttrack', () => {
                // Navigate to next episode
                playNextEpisode();
            });

            // Update playback state
            navigator.mediaSession.playbackState = (isPlaying && !isPaused) ? 'playing' : 'paused';

            console.log('Media Session API initialized');
        }

        // Call updateMediaSession when playback state changes
        const originalTogglePlayPause = togglePlayPause;
        togglePlayPause = function() {
            originalTogglePlayPause();
            updateMediaSession();
        };

        const originalStartPlayback = startPlayback;
        startPlayback = function() {
            originalStartPlayback();
            updateMediaSession();
        };

        const originalStopPlayback = stopPlayback;
        stopPlayback = function() {
            originalStopPlayback();
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'paused';
            }
        };
    </script>
</body>
</html>
